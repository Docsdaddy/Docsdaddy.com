<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Docs Daddy — Image Compressor</title>
  <style>
    :root{--accent:#0ea5a4;--bg:#0f172a;--card:#0b1220;color:#e6eef3}
    *{box-sizing:border-box;font-family:Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial}
    body{margin:0;min-height:100vh;background:linear-gradient(180deg,#021027 0%, #071426 100%);color:var(--card);display:flex;align-items:center;justify-content:center;padding:28px}
    .wrapper{width:100%;max-width:920px;background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));border-radius:14px;padding:20px;box-shadow:0 10px 30px rgba(2,6,23,0.6)}
    h1{margin:0 0 8px;font-size:20px}
    p.lead{margin:0 0 18px;color:#b8d1d0}
    .grid{display:grid;grid-template-columns:1fr 320px;gap:18px}
    .card{background:rgba(255,255,255,0.02);padding:14px;border-radius:10px}
    label{display:block;font-size:13px;color:#cfe8e6;margin-bottom:6px}
    input[type=file]{display:block}
    .row{display:flex;gap:8px;align-items:center}
    input[type=number], select, input[type=text]{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    button{background:var(--accent);border:none;padding:10px 14px;border-radius:8px;color:#002;cursor:pointer;font-weight:600}
    .muted{color:#9fb6b5;font-size:13px}
    .preview{display:flex;flex-direction:column;gap:10px;align-items:center}
    img.preview-img{max-width:100%;max-height:360px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
    .stats{display:flex;gap:8px;flex-wrap:wrap}
    .chip{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:20px;font-size:13px}
    footer{margin-top:12px;font-size:13px;color:#9fb6b5}
    .warn{color:#ffd4a3}
    @media(max-width:880px){.grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrapper">
    <h1>Docs Daddy — Image Compressor</h1>
    <p class="lead">Compress your image to the same file type and download it — Enter your desired size in KB/MB and click <strong>Compress</strong>.</p>

    <div class="grid">
      <div class="card">
        <label>1) Choose an image</label>
        <input id="fileInput" type="file" accept="image/*">
        <div style="height:12px"></div>
        <label>2) Target size (KB or MB)</label>
        <div class="row" style="gap:10px">
          <input id="targetSize" type="number" min="1" value="200">
          <select id="unit">
            <option value="KB">KB</option>
            <option value="MB">MB</option>
          </select>
        </div>
        <div style="height:12px"></div>
        <label>Optional: For JPEG/WebP set max quality (0.1 - 0.95)</label>
        <input id="maxQuality" type="number" step="0.01" min="0.1" max="0.95" value="0.92">
        <div style="height:12px"></div>
        <div class="row">
          <button id="compressBtn">Compress</button>
          <button id="downloadBtn" disabled>Download</button>
          <div style="flex:1"></div>
        </div>
        <div style="height:10px"></div>
        <div class="muted">Notes: Animated GIFs will be flattened (animation lost). SVGs are minified as text.</div>
        <div style="height:10px"></div>
        <div id="log" class="muted"></div>
      </div>

      <div class="card">
        <div class="preview">
          <div style="width:100%">
            <label>Preview</label>
            <img id="previewImg" class="preview-img" alt="preview" src=""/>
          </div>

          <div class="stats">
            <div class="chip">Original: <span id="origSize">-</span></div>
            <div class="chip">Compressed: <span id="compSize">-</span></div>
            <div class="chip">Type: <span id="mimeType">-</span></div>
            <div class="chip">Dimensions: <span id="dims">-</span></div>
            <div class="chip">Time: <span id="time">-</span></div>
          </div>
        </div>
      </div>
    </div>

    <footer>Made with ❤ by Docs Daddy — Client-side compression (no server upload). Keep file sizes and privacy in mind.</footer>
  </div>

<script>
  const $ = id => document.getElementById(id);
  const fileInput = $('fileInput');
  const previewImg = $('previewImg');
  const origSize = $('origSize');
  const compSize = $('compSize');
  const mimeTypeEl = $('mimeType');
  const dims = $('dims');
  const timeEl = $('time');
  const log = $('log');
  const compressBtn = $('compressBtn');
  const downloadBtn = $('downloadBtn');

  let originalFile = null;
  let compressedBlob = null;
  let compressedMime = null; // store actual mime of compressed blob

  fileInput.addEventListener('change', async (e) => {
    const f = e.target.files[0];
    reset();
    if(!f) return;
    originalFile = f;
    mimeTypeEl.textContent = f.type || 'unknown';
    origSize.textContent = formatBytes(f.size);
    const url = URL.createObjectURL(f);
    previewImg.src = url;
    previewImg.onload = () => { dims.textContent = previewImg.naturalWidth + '×' + previewImg.naturalHeight; URL.revokeObjectURL(url); }
  });

  function reset(){ compressedBlob = null; compressedMime = null; compSize.textContent = '-'; downloadBtn.disabled = true; timeEl.textContent='-'; log.textContent=''; }

  function formatBytes(bytes){ if(bytes<1024) return bytes+' B'; if(bytes<1024*1024) return (bytes/1024).toFixed(1)+' KB'; return (bytes/1024/1024).toFixed(2)+' MB'; }

  compressBtn.addEventListener('click', async () => {
    if(!originalFile){ alert('Please select an image first'); return; }
    const target = parseFloat($('targetSize').value) || 200;
    const unit = $('unit').value || 'KB';
    const maxQuality = parseFloat($('maxQuality').value) || 0.92;
    const targetBytes = unit === 'MB' ? target * 1024 * 1024 : target * 1024;

    const start = performance.now();
    log.textContent = 'Compressing...';

    try{
      const result = await compressImageFile(originalFile, targetBytes, maxQuality);
      // result: {blob, mime}
      compressedBlob = result.blob || null;
      compressedMime = result.mime || (compressedBlob && compressedBlob.type) || null;

      if(!compressedBlob){ throw new Error('Compression failed'); }

      compSize.textContent = formatBytes(compressedBlob.size);
      timeEl.textContent = ((performance.now()-start)/1000).toFixed(2)+'s';
      downloadBtn.disabled = false;
      log.textContent = 'Done — click Download to save your compressed image.';

      const url = URL.createObjectURL(compressedBlob);
      previewImg.src = url;
      previewImg.onload = () => { dims.textContent = previewImg.naturalWidth + '×' + previewImg.naturalHeight; URL.revokeObjectURL(url); }

    }catch(err){ console.error(err); log.textContent = 'Error: '+err.message; }
  });

  downloadBtn.addEventListener('click', () => {
    if(!compressedBlob) return;
    const a = document.createElement('a');
    // determine extension from actual mime
    const ext = mimeToExtension(compressedMime || compressedBlob.type || originalFile.type || 'image/png');
    const dotIndex = originalFile.name.lastIndexOf('.');
    const baseName = dotIndex > -1 ? originalFile.name.slice(0, dotIndex) : originalFile.name;
    const name = baseName + '-compressed.' + ext;
    a.href = URL.createObjectURL(compressedBlob);
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
  });

  function mimeToExtension(mime){
    if(!mime) return 'png';
    if(mime.indexOf('jpeg') !== -1) return 'jpg';
    if(mime.indexOf('png') !== -1) return 'png';
    if(mime.indexOf('webp') !== -1) return 'webp';
    if(mime.indexOf('gif') !== -1) return 'gif';
    if(mime.indexOf('svg') !== -1) return 'svg';
    return mime.split('/').pop();
  }

  // compressImageFile returns {blob, mime}
  async function compressImageFile(file, targetBytes, maxQuality){
    const originalType = file.type || detectTypeFromName(file.name);

    if(originalType === 'image/svg+xml'){
      const text = await file.text();
      const min = text.replace(/>\s+</g, '><').replace(/\s{2,}/g,' ').trim();
      const blob = new Blob([min], {type:'image/svg+xml'});
      return {blob, mime: 'image/svg+xml'};
    }

    // create image element
    const img = await loadImageFromFile(file);
    let width = img.naturalWidth;
    let height = img.naturalHeight;

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    // draw original
    canvas.width = width; canvas.height = height; ctx.clearRect(0,0,width,height);
    ctx.drawImage(img,0,0,width,height);

    // if already under target, return original file as-is
    if(file.size <= targetBytes){
      return {blob: file, mime: file.type || originalType};
    }

    // helper: try to export canvas as blob with preferred mime, fall back to alternatives
    async function tryExport(quality, preferredMime){
      const candidates = [preferredMime, 'image/webp', 'image/jpeg', 'image/png'];
      for(const m of candidates){
        try{
          const blob = await canvasToBlob(canvas, m, quality);
          if(blob) return {blob, mime: m};
        }catch(e){
          // continue to next candidate
        }
      }
      return null;
    }

    // If original is JPEG or WebP, try quality reductions first
    const isJPEG = originalType === 'image/jpeg' || originalType === 'image/jpg';
    const isWebP = originalType === 'image/webp';

    if(isJPEG || isWebP){
      const qualitySteps = generateQualitySteps(maxQuality);
      for(const q of qualitySteps){
        const r = await tryExport(q, originalType);
        if(r && r.blob.size <= targetBytes) return r;
      }
    }

    // iterative downscale + quality tries
    let currW = width, currH = height;
    let lastSuccessful = null;
    for(let attempt=0; attempt<12; attempt++){
      currW = Math.max(Math.round(currW * 0.9), 10);
      currH = Math.max(Math.round(currH * 0.9), 10);
      canvas.width = currW; canvas.height = currH; ctx.clearRect(0,0,currW,currH);
      ctx.drawImage(img,0,0,currW,currH);

      if(isJPEG || isWebP){
        const qualities = [maxQuality, Math.max(0.85,maxQuality-0.1), 0.7, 0.5, 0.35];
        for(const q of qualities){
          const r = await tryExport(q, originalType);
          if(r){
            lastSuccessful = r;
            if(r.blob.size <= targetBytes) return r;
          }
        }
      } else {
        const r = await tryExport(0.92, originalType);
        if(r){ lastSuccessful = r; if(r.blob.size <= targetBytes) return r; }
      }

      if(currW <= 64 || currH <= 64) break;
    }

    if(lastSuccessful) return lastSuccessful;

    const fallback = await tryExport(0.4, 'image/jpeg');
    if(fallback) return fallback;

    return {blob: file, mime: file.type || originalType};
  }

  // promisified canvas.toBlob with proper rejection handling
  function canvasToBlob(canvas, mime, quality){
    return new Promise((resolve, reject) => {
      try{
        canvas.toBlob((blob) => {
          resolve(blob);
        }, mime, quality);
      }catch(e){ reject(e); }
    });
  }

  function detectTypeFromName(name){
    const ext = name.split('.').pop().toLowerCase();
    if(ext === 'jpg' || ext === 'jpeg') return 'image/jpeg';
    if(ext === 'png') return 'image/png';
    if(ext === 'webp') return 'image/webp';
    if(ext === 'gif') return 'image/gif';
    if(ext === 'svg') return 'image/svg+xml';
    return 'image/*';
  }

  function generateQualitySteps(maxQ){
    const arr = [];
    let q = Math.max(Math.min(maxQ, 0.95), 0.1);
    while(q >= 0.1){ arr.push(parseFloat(q.toFixed(2))); q -= (q>0.7?0.08: q>0.4?0.05:0.03); }
    if(arr[arr.length-1] !== 0.1) arr.push(0.1);
    return arr;
  }

  function loadImageFromFile(file){
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
      img.onerror = () => { URL.revokeObjectURL(url); reject(new Error('Cannot load image')); };
      img.src = url;
    });
  }
</script>
</body>
</html>
